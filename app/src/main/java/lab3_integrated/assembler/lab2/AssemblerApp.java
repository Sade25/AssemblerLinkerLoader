/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lab3_integrated.assembler.lab2;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import lab3_integrated.assembler.MOT.Machine_Op_Table;
import lab3_integrated.assembler.POT.Pseudo_Op_Table;
import lab3_integrated.assembler.Passes.Pass1;
import lab3_integrated.assembler.Passes.Pass2;
import lab3_integrated.assembler.Passes.String_Parser;
import lab3_integrated.assembler.lab2.Exceptions.Pass2Exception;
import lab3_integrated.assembler.lab2.Validate.Locations;

public class AssemblerApp {

	public static void main(String[] args) throws Pass2Exception {
		ArrayList<List<String>> lines = new ArrayList<List<String>>();
		HashMap<String, String[]> SymTable = new HashMap<String, String[]>();
		HashMap<String, Integer> LitTable = new HashMap<String, Integer>();
		Pseudo_Op_Table pot = new Pseudo_Op_Table();
		Machine_Op_Table mot = new Machine_Op_Table();
		FileWriter objectFile = null, listingFile = null;
		Pass2 pass2;
		int segSize;
		String_Parser sp = new String_Parser();
		
		if (args.length < 4) {
			System.err.println("Not enough arguments were provided to the program."
					+ "This program requires three arguments in the following order: ./program <input path> <object file output path> <listing file output path>");
			System.exit(0);
		}
		Validate validator = new Validate(mot);
		try {

			FileReader asmFile = new FileReader(args[1]);
			BufferedReader reader = new BufferedReader(asmFile);
			FileReader tempAsmFile = new FileReader(args[1]);
			BufferedReader tempReader = new BufferedReader(tempAsmFile);

			if (tempReader.lines().findAny().isEmpty()) {
				tempReader.close();
				reader.close();
				throw new IllegalArgumentException("An Empty File is NOT valid");
			}
			tempReader.close();

			AtomicInteger lineCount = new AtomicInteger();
			lineCount.set(1); // start at line 1
			reader.lines().forEachOrdered((String line) -> {
				lineCount.getAndIncrement();
				try {
					List<String> tempList = validator.validate(line, lines, lineCount.get());
					if (tempList != null) {
						lines.add(tempList);
						if (lines.size() > 200) {
							System.out.println("Too many lines");
							System.exit(1);
						}
					}
				} catch (Exception e) {
					System.err.println(
							"Error: " + e.getMessage() + " On line " + lineCount.get() + "\nLine: " + line);
					System.exit(0);
				}
			});
			reader.close();
		} catch (Exception e) {
			System.err.println("Error: " + e.getMessage());
			System.exit(0);
		}
		try {
			objectFile = new FileWriter(args[2]);
		} catch (IOException e) {
			System.err.println("Error: " + e.getMessage());
			System.exit(0);
		}

		try {
			listingFile = new FileWriter(args[3]);
		} catch (IOException e) {
			System.err.println("Error: " + e.getMessage());
			System.exit(0);
		}

		int locCount = 0;
		if (lines.size() > 0 && !lines.get(0).get(Locations.OPERANDS).isEmpty()) {
			if (!sp.canParseInt(lines.get(0).get(Locations.OPERANDS))) {
				throw new Pass2Exception("Address defined for .ORIG is invalid");
			}
			locCount = Integer.parseInt(lines.get(0).get(Locations.OPERANDS).substring(1), 16);
		} else {
			locCount = 0x0;
		}
		int startAddress = locCount;
		locCount = Pass1.fillTables(lines, locCount, SymTable, LitTable);
		segSize = locCount - startAddress;
		pass2 = new Pass2(mot, pot, SymTable, LitTable, objectFile, listingFile, segSize);

		try {
			pass2.parseInput(lines);
		} catch (Pass2Exception e) {
			System.err.println("Error: " + e.getMessage());
			e.printStackTrace();
		}

		if (!validator.doesFileContainsOrigAndEnd()) {
			System.err.println("A file must Have excatly one .ORIG and one .END psuedo op");
		}
	}
}